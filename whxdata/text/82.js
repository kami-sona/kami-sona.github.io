rh._.exports({"0":[[" ",".FUNC — User Defined Functions"]],"1":[[".FUNC"]],"2":[[" ",".FUNC — User Defined Functions"]],"3":[[" ","Syntax:"," ",".func <name>([args]) {<expression>}"," ","Example:"," ",".func Pythag(x,y) {sqrt(x*x+y*y)}"," ","The .func directive allows the creation of user-defined functions for use with user parameterized circuits and behavioral sources. This is useful for associating a name with a function for the sake of clarity and parameterizing subcircuits so that abstract circuits can be saved in libraries."," ","The .func statement can be included inside a subcircuit definition to limit the scope the function to that subcircuit and the subcircuits invoked by that subcircuit."," ","Below is an example using both a .func and .param statements."," ","* Example using a .func statement","\n      .func myfunc(x,y) {sqrt(x*x+y*y)}","\n      .param u=100 v=600","\n      V1 a 0 pulse(0 1 0 1n 1n .5μ 1μ)","\n      R1 a b {myfunc(u,v/3)}","\n      C1 b 0 100p"," ","All parameter substitution evaluation is done before the simulation begins."," ","User-defined functions use dynamic scoping. The meaning of any name used inside a function's expression depends on where the function is used. For example, in the following netlist:"," ",".param voltage=1","\n      .func doubled() { 2 * voltage }","\n      .subckt example out","\n      V1 out 0 {doubled()}","\n      .param voltage=10","\n      .ends","\n      X1 n1 example"," ","the voltage at node n1 is 20V, because the function ","doubled()"," is evaluated inside the subcircuit where the user-defined constant ","voltage"," has the value 10."," ","Copyright © 1998–2025 by Analog Devices Inc. All Rights Reserved."]],"id":"82"})